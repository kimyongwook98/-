<h3 id="분산-데이터베이스-설계">분산 데이터베이스 설계</h3>
<p>1) 분산 데이터베이스 정의</p>
<ul>
<li>논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트Site에 분산돼 있는 데이터베이스</li>
</ul>
<p>2) 분산 데이터베이스의 구성 요소</p>
<ul>
<li>분산 처리기 : 자체적으로 처리 능력을 가지며, 
지리적으로 분산되어 있는 컴퓨터 시스템</li>
<li>분산 데이터베이스 : 지리적으로 분산되어 있는 데이터 베이스, 
해당 지역의 특성에 맞게 구성된 데이터 베이스</li>
<li>통신 네트워크 : 분산 처리기들을 통신망으로 연결해 논리적으로 하나의 시스템처럼 작동할 수 있도록 하는 통신 네트워크</li>
</ul>
<p>3) 분산 데이터베이스의 목표 </p>
<ul>
<li>위치 투명성(Location Transparency) : 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스할 수 있음</li>
<li>중복 투명성 : (Replication Transparency, 복제 투명성)    동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행</li>
<li>병행 투명성(Concurrency Transparency) : 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않음</li>
<li>분할 투명성(Division Transparency) : 하나의 논리적 릴레이션이 여러 단편으로 분할되어 각 단편의 사본이 여려 시스템에 저장되어 있음을 인식할 필요가 없음</li>
<li>장애 투명성(Failure Transparency) : 트랜잭션, DBMS, 네트워크, 컴퓨터 장애가 발생해도 트랜잭션을 정확하게 처리하고 데이터 무결성을 보장</li>
</ul>
<p>4) 분산 데이터베이스의 장, 단점</p>
<ul>
<li>장점</li>
<li>지역 자치성이 높음</li>
<li>자료의 공유성 향상</li>
<li>분산 제어 가능</li>
<li>시스템 성능 향상</li>
<li>중앙 컴퓨터의 장애가 전체 시스템에 영향을 끼치지 않음</li>
<li>효용성과 융통성이 높음</li>
<li>신뢰성 및 가용성이 높음</li>
<li>점진적 시스템 용량 확장이 용이    </li>
<li>단점</li>
<li>DBMS가 수행할 기능이 복잡</li>
<li>데이터베이스 설계가 어려움</li>
<li>소프트웨어 개발 비용 증가</li>
<li>처리 비용 증가</li>
<li>잠재적 오류 증가 (사이트 간의 오류 발생률 높음) → 보안의 어려움</li>
</ul>
<p>5) 분산 데이터베이스 설계</p>
<ul>
<li>애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하게 하는 것을 목적</li>
</ul>
<p>▶ 분산 설계 방법
 -테이블 위치 분산 : 테이블을 각기 다른 서버에 분산시켜 배치하는 방법
 -분할(Fragmentation) : 테이블의 데이터를 분할하여 분산시키는 것
 -할당(Allocation) : 동일한 분할을 여러 개의 서버에 생성하는 방법
  (중복이 없는 할당, 중복이 있는 할당)</p>
<h3 id="데이터베이스-이중화--서버-클러스터링">데이터베이스 이중화 / 서버 클러스터링</h3>
<p>1) 데이터베이스 이중화(Database Replication)</p>
<ul>
<li>시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제해 관리하는 것</li>
</ul>
<p>2) 데이터베이스 이중화의 분류</p>
<ul>
<li>Eager 기법 : 트랜잭션 수행 중 데이터 변경이 발생하면 이중화 된 모든 데이터베이스에 즉신 전달해 변경 내용이 즉시 적용되도록 하는 기법</li>
<li>Lazy 기법 : 트랜잭션의 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성해 각 데이터베이스에 전달되는 기법
→ 데이터베이스마다 새로운 트랜잭션이 수행되는 것으로 간주됨</li>
</ul>
<p>3) 데이터베이스 이중화 구성 방법</p>
<ul>
<li>활동-대기(Active-Standby) : 한 DB가 활동 상태로 서비스하고 있으면 다른 DB는 대기하고 있다가 활동 DB에 장애가 발생하면 대기 상태에 있던 DB가 자동으로 모든 서비스를 대신 수행
→ 구성 방법 및 관리가 쉬워 많은 기업에서 이용함</li>
<li>활동-활동(Active-Active) : 두 개의 DB가 서로 다른 서비스를 제공하다가 둘 중 한쪽 DB에 문제가 발생하면 나머지 다른 DB가 서비스를 제공
→ 두 DB 모두 처리를 하기 때문에 처리율이 높지만 구성 방법 및 설정이 복잡함</li>
</ul>
<p>4) 서버 클러스터링(Server Clustering)</p>
<ul>
<li>두 대 이상의 서버를 하나의 서버처럼 운영하는 기술
▶ 고가용성 클러스터링: 하나의 서버에 장애 발생 → 다른 서버가 대신 처리
▶ 병렬 처리 클러스터링: 하나의 작업을 여러 개의 서버에 분산해 처리</li>
</ul>
<h3 id="데이터베이스-보안--스토리지">데이터베이스 보안 / 스토리지</h3>
<p>1) 데이터베이스 보안의 개요</p>
<ul>
<li>데이터베이스 일부분 또는 전체에 대해서 권한이 없는 사용자가 액세스하는 것을 금지하기 위해 사용되는 기술</li>
<li>데이터베이스 사용자들은 일반적으로 서로 다른 객체에 대해 다른 접근 권리 또는 권한을 가짐</li>
</ul>
<p>2) 암호화(Encryption)
▶ 암호화(Encryption) 과정
 -암호화되지 않은 평문을 정보 보호를 위해 암호문으로 바꾸는 과정
 -개인키 암호 방식(대칭키), 공개키 암호 방식(비대칭키)
▶ 복호화(Decryption) 과정
 -암호문을 원래의 평문으로 바꾸는 과정</p>
<p>3) 암호화 방식</p>
<ul>
<li>개인키 암호 방식(Private Key Encryption, 비밀키 암호 방식, 대칭키)
: 동일한 키로 데이터를 암호화하고 복호화 함
: 비밀키는 DB 사용 권한이 있는 사용자만 나눠 가짐<br />: 종류 / DES, AES, SEED, ARIA</li>
<li>공개키 암호방식(Public Key Encryption, 비대칭키)
: 데이터를 암호화할 때 사용하는 키(공개키)는 DB 사용자에게 공개하고, 복호화할 때의 키(비밀키)는 관리자가 관리하는 방법<br />: 종류 / RSA (Rivest Shamir Adleman), Diffie Hellman Algorithm</li>
</ul>
<p>4) 접근통제</p>
<ul>
<li>데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것</li>
<li>접근통제 3요소 : 접근통제 정책, 접근통제 보안모델, 접근통제 메커니즘
▶ 임의 접근통제(DAC; Discretionary Access Control)
-데이터에 접근하는 사용자의 신원에 따라 접근 권한 부여
-접근통제 권한=주체
▶ 강제 접근통제(MAC; Mandatory Access Control)
-주체와 객체의 등급을 비교해 접근 권한 부여
-접근통제 권한=제3자</li>
</ul>
<p>5) 접근통제 정책</p>
<ul>
<li>신분 기반 정책(DAC) : 주체나 그룹의 신분에 근거해 객체의 접근을 제한하는 방법 / IBP(Individual-Based Policy), GBP(Group-Based Policy)</li>
<li>규칙 기반 정책(MAC) : 주체가 갖는 권한에 근거해 객체의 접근을 제한하는 방법 / MLP(Multi-Level Policy), CBP(Compartment-Based Policy)</li>
<li>역할 기반 정책(RBAC) : 주체가 맡은 역할에 근거해 객체의 접근을 제한하는 방법 / 인사 담당자, DBA(Database Administration)</li>
</ul>
<p>6) 접근통제 메커니즘
▶ 접근통제 목록(ACL; Access Control List) : 객체를 기준으로 특정 객체에 대해 어떤 주체가 어떤 행위를 할 수 있는지를 기록한 목록 
▶ 능력 리스트(CL; Capability List) : 주체를 기준으로 주체에게 허가된 자원 및 권한을 기록한 목록
▶ 보안 등급(Security Label), 패스워드, 암호화</p>
<p>7) 접근통제 보안 모델</p>
<ul>
<li>기밀성 모델 : 군사적인 목적으로 개발된 최초의 수학적 모델, 기밀성 보장 최우선 </li>
<li>벨라파듈라 모델 : No Read UP(기밀성), No Write Down</li>
<li>무결성 모델: 불법적인 정보 변경을 방지하기 위해 무결성을 기반으로 개발된 모델</li>
<li>비바 모델 : No Read Down, No Write Up(무결성)</li>
<li>접근통제 모델 : 접근통제 메커니즘을 보안 모델로 발전시킨 것</li>
<li>접근통제 행렬(Access Control Matrix) : 행=주체, 열=객체</li>
</ul>
<p>8) 데이터베이스 백업 종류</p>
<ul>
<li>물리 백업
로그 파일 백업 실시    : 완전 복구
로그 파일 백업 없음    : 백업 시점까지 복구</li>
<li>논리 백업<br />DBMS 유틸리티 : 백업 시점까지 복구    </li>
<li>로그 파일: 데이터베이스의 상태 변화를 시간의 흐름에 따라 모두 기록한 파일</li>
</ul>
<p>9) 스토리지(Storage)</p>
<ul>
<li>DAS(Direct Attached Storage) : 서버와 저장장치를 전용 케이블로 직접 연결하는 방식    속도가 빠르고 설치 및 운영이 쉬움, 초기 구축 및 유지보수 비용 저렴    파일 공유 불가, 확장성 및 유연성이 떨어짐</li>
<li>NAS(Network Attached Storage) : 서버와 저장장치를 네트워크를 통해 연결하는 방식    장소에 구애받지 않고 저장장치에 쉽게 접근, 확장성 및 유연성 우수    접속 증가 시 성능 저하</li>
<li>SAN(Storage Area Network) : 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성한 방식    파이버 채널 스위치로 네트워크 구성, 광케이블로 처리속도 빠름, 확장성, 유연성, 가용성 뛰어남    설치 비용이 많이 듦</li>
</ul>
<h3 id="논리-데이터-모델의-물리-데이터-모델-변환-및-품질-검토">논리 데이터 모델의 물리 데이터 모델 변환 및 품질 검토</h3>
<p>1) 일반적인 변환 절차
▶ 단위 개체를 테이블로 변환 → 속성을 컬럼으로 변환 → UID(Unique Identifier)를 기본 키(Primary Key)로 변환 → 관계를 외래 키(Foreign Key)로 변환 → 컬럼 유형(Type)과 길이(Length) 정의 → 반정규화(De-normalization) 수행</p>
<p>2) 슈퍼타입/서브타입을 테이블로 변환
-슈퍼타입 기준 테이블 변환: 서브타입을 슈퍼타입에 통합해 하나의 테이블로 만드는 것
-서브타입 기준 테이블 변환: 슈퍼타입 속성들을 각각의 서브타입에 추가해 서브타입들을 개별적인 테이블로 만드는 것
-개별타입 기준 테이블 변환: 슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환하는 것</p>
<p>3) 물리 데이터 모델 품질 기준 (=논리 데이터 모델 품질 기준)</p>
<ul>
<li>정확성 : 요구사항이나 업무 규칙, 표기법에 따라 정확하게 표현됨</li>
<li>완전성 : 데이터 모델의 구성 요소를 누락 없이 정의하고, 요구사항이나 업무 영역을 누락 없이 반영함</li>
<li>준거성 : 데이터 표준, 표준화 규칙, 법적 요건 등을 정확하게 준수함</li>
<li>최신성 : 최근의 이슈나 현행 시스템을 반영함</li>
<li>일관성 : 표현상의 일관성을 유지함</li>
<li>활용성 : 업무 변화에 따른 데이터 구조의 변경이 최소화될 수 있도록 설계됨</li>
</ul>