<h3 id="정규화normalization-반정규화denormalization">정규화(Normalization), 반정규화(Denormalization)</h3>
<ul>
<li>하나의 종속성이 하나의 릴레이션에 표현될 수 있도록 분해해가는 과정</li>
<li>데이터베이스의 논리적 설계 단계에서 수행<h4 id="정규화의-목적">정규화의 목적</h4>
</li>
<li>데이터 구조의 안정성 및 무결성을 유지</li>
<li>어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만듦</li>
<li>효과적인 검색 알고리즘 생성 가능</li>
<li>데이터 중복을 배제해 이상(Anomaly)의 발생 방지 및 자료 저장 공간의 최소화</li>
<li>개체와 속성의 누락 여부 확인 가능</li>
<li>데이터 삽입 시 릴레이션을 재구성할 필요성을 줄임</li>
</ul>
<h4 id="이상anomaly의-개념-및-종류">이상(Anomaly)의 개념 및 종류</h4>
<ul>
<li>정규화를 거치지 않아 데이터베이스 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 못하게 발생하는 곤란한 현상
▶ 삽입 이상(Insertion Anomaly) : 릴레이션에 데이터를 삽입할 때 의도와 상관없이 원하지 않은 값들도 함께 삽입되는 현상
▶ 삭제 이상(Deletion Anomaly) : 릴레이션에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 현상
▶ 갱신 이상(Update Anomaly) : 릴레이션에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상</li>
</ul>
<h4 id="정규화의-원칙">정규화의 원칙</h4>
<ul>
<li>정보의 무손실, 분리의 원칙, 데이터의 중복성 감소<h4 id="정규화-과정">정규화 과정</h4>
</li>
<li>1NF(제1정규형) : 릴레이션에 속한 모든 도메인이 원자 값(Atomic Value)만으로 되어 있는 정규형</li>
<li>2NF(제2정규형) : 릴레이션 R이 1NF고, 기본키가 아닌 모든 속성이 기본키에 대해 완전 함수적 종속을 만족하는, 부분적 함수 종속을 제거한 정규형 </li>
<li>3NF(제3정규형) : 릴레이션 R이 2NF고, 기본키가 아닌 모든 속성이 기본키에 대해 *이행적 함수 종속 관계를 만족하지 않는 정규형
: A → B이고 B → C일 때 A → C를 만족하는 관계(이행 규칙)</li>
<li>BCNF(Boyce-Codd 정규형) : 릴레이션 R에서 모든 결정자가 후보키인 정규형,
모든 BCNF가 종속성을 보존하는 것은 아님 (강한 제3정규형, 보이스/코드 정규형)</li>
<li>4NF(제4정규형) : 릴레이션 R에 다치 종속이 성립하는 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형</li>
<li>5NF(제5정규형) : 릴레이션 R의 모든 조인 종속이  R의 후보키를 통해서만 성립되는 정규형</li>
</ul>
<h4 id="반정규화-개념">반정규화 개념</h4>
<ul>
<li>시스템 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 의도적으로 정규화 원칙을 위배하는 행위</li>
<li>그러나 데이터의 일관성 및 정합성이 저하될 수 있음</li>
</ul>
<h4 id="반정규화-방법">반정규화 방법</h4>
<ul>
<li>테이블 통합 : 1:1 관계 | 1:N 관계 | 슈퍼타입/서브타입 {테이블 통합}</li>
<li>테이블 분할 : 수평 분할, 수직 분할 → 기본키의 유일성 관리가 어려워짐</li>
<li>중복 테이블 추가 : 집계 테이블 | 진행 테이블 | 특정 부분만을 포함하는 테이블 {추가}</li>
<li>중복 속성 추가 : 자주 사용하는 속성을 하나 더 추가하는 것<h3 id="시스템-카탈로그system-catalog">시스템 카탈로그(System Catalog)</h3>
<h4 id="시스템-카탈로그의-의미">시스템 카탈로그의 의미</h4>
</li>
<li>사용자를 포함해 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블</li>
<li>좁은 의미로는 카탈로그를 데이터 사전이라고도 함</li>
<li>시스템 카탈로그에 저장된 정보를 메타 데이터라고 함</li>
</ul>
<h4 id="카탈로그의-특징">카탈로그의 특징</h4>
<ul>
<li>일반 이용자도 SQL을 이용해 내용을 검색할 수 있음</li>
<li>INSERT, DELETE, UPDATE문으로 카탈로그를 갱신할 수 없음</li>
<li>DBMS에 따라 상이한 구조를 갖음</li>
<li>카탈로그는 DBMS가 스스로 생성하고 유지함</li>
<li>사용자가 SQL문을 실행시켜 변화를 주면 시스템이 자동으로 갱신함</li>
</ul>
<h4 id="데이터-디렉터리data-directory-사전-관리기">데이터 디렉터리(Data Directory, 사전 관리기)</h4>
<ul>
<li>데이터 사전(Data Dictionary)에 수록된 데이터를 실제로 접근하는 데 필요한 정보를 관리 유지하는 시스템</li>
<li>시스템만 접근할 수 있음
cf) 시스템 카탈로그(데이터 사전) : 사용자와 시스템 모두 접근할 수 있음</li>
</ul>
<h3 id="데이터베이스-저장-공간-설계">데이터베이스 저장 공간 설계</h3>
<h4 id="테이블table">테이블(Table)</h4>
<ul>
<li>데이터베이스의 가장 기본적인 객체로 행(Row, 튜플), 열(Column, 컬럼)로 구성</li>
<li>논리 설계 단계의 개체(Entity)에 대응하는 객체</li>
</ul>
<h4 id="클러스터드-인덱스-테이블clustered-index-table">클러스터드 인덱스 테이블(Clustered Index Table)</h4>
<ul>
<li>기본키나 인덱스키의 순서에 따라 데이터가 저장되는 테이블</li>
<li>일반적인 인덱스를 사용하는 테이블에 비해 접근 경로가 단축됨</li>
</ul>
<h4 id="파티셔닝-테이블partitioning-table">파티셔닝 테이블(Partitioning Table)</h4>
<ul>
<li>대용량의 테이블을 작은 논리적 단위인 파티션으로 나는 테이블</li>
<li>파티션 키를 잘못 구성하면 성능 저하 등의 역효과 초래
1) 레인지 파티셔닝 : 지정한 열의 값을 기준으로 분할 (범위분할)
ex) 일별, 월별, 분기별 등
2) 해시 파티셔닝 : 해시 함수에 따라 데이터 분할 (해시분할)
3) 리스트 파티셔닝(List Partitioning) : 미리 정해진 그룹핑 기준에 따라 분할
4) 컴포지트 파티셔닝(Composite Partitioning) : 레인지 파티셔닝 이후 해시 함수를 적용 (조합분할)
ex) 범위분할 + 해시분할</li>
</ul>
<p>▶ 파티션의 장점
 -성능 향상, 가용성 향상, 백업 가능, 경합 감소</p>
<h4 id="외부-테이블external-table">외부 테이블(External Table)</h4>
<ul>
<li>데이터베이스에서 일반 테이블처럼 이용할 수 있는 외부 파일
데이터 웨어하우스(Data Warehouse), ETL(Extraction, Transformation, Loading)</li>
</ul>
<h3 id="임시-테이블temporary-table">임시 테이블(Temporary Table)</h3>
<ul>
<li>트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블</li>
<li>임시테이블에 저장된 데이터는 트랜잭션이 종료되면 삭제됨</li>
<li>절차적인 처리를 위해 임시로 사용하는 테이블</li>
</ul>
<h4 id="컬럼column-열">컬럼(Column, 열)</h4>
<ul>
<li>가변 길이 데이터 타입 : 예상되는 최대 길이로 정의</li>
<li>고정 길이 데이터 타입 : 최소 길이로 지정</li>
<li>소수점 이하 자릿수 : 소수점 이하 자릿수는 반올림되어 저장</li>
<li>고정 길이 컬럼이고 NOT NULL인 컬럼 : 앞</li>
<li>가변 길이 컬럼, NULL값이 많을 것으로 예상되는 컬럼 : 뒤</li>
</ul>
<h4 id="테이블스페이스tablespace">테이블스페이스(Tablespace)</h4>
<ul>
<li>테이블이 저장되는 논리적인 영역</li>
<li>테이블을 저장하면 논리적으로는 테이블스페이스에 저장되고, 물리적으로는 해당 테이블스페이스와 연관된 데이터 파일에 저장
▶ 테이블스페이스 설계 시 고려사항
-업무별로 구분해 지정하고, 테이블과 인덱스는 분리해 저장
-대용량 테이블은 하나의 테이블스페이스에 독립적으로 저장
-LOB(Large Object) 타입의 데이터는 독립적인 공간으로 지정<h3 id="트랜잭션transaction">트랜잭션(Transaction)</h3>
1) 트랜잭션의 정의</li>
<li>데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위</li>
<li>한꺼번에 모두 수행되어야 할 일련의 연산들
▶ COMMIT : 트랜잭션 처리가 정상적으로 종료되어 수행한 변경 내용을 DB에 반영하는 명령어
▶ ROLLBACK : 트랜잭션 처리가 비정상으로 종료되어 DB의 일관성이 깨졌을 때 트랜잭션이 행한 모든 변경 작업을 취소하고 이전 상태로 되돌리는 연산
▶ SAVEPOINT(=CHECKPOINT) : 트랜잭션 내에서 ROLLBACK할 위치인 저장점을 지정하는 명령어, 여러 개의 SAVEPOINT 지정 가능</li>
<li>COMMIT과 ROLLBACK 명령어에 의해 보장 받는 트랜잭션 특징 = 원자성 </li>
</ul>
<h4 id="트랜잭션의-특성">트랜잭션의 특성</h4>
<p>원자성(Atomicity) : 트랜잭션 연산을 데이터베이스 모두에 반영되든지 아니면 전혀 반영되지 않아야 함(All or Nothing) ★
일관성(Consistency) : 트랜잭션이 실행을 성공적으로 완료할 시 일관성 있는 데이터베이스 상태를 유지
독립성(Isolation, 격리성) : 둘 이상 트랜잭션 동시 실행 시 한 개의 트랜잭션만 접근이 가능하여 간섭 불가
영속성(Durability) : 성공적으로 완료된 트랜잭션 결과는 영구적으로 반영됨</p>
<h4 id="crud-매트릭스">CRUD 매트릭스</h4>
<ul>
<li>Create, Read, Update, Delete, ‘C &gt; D &gt; U &gt; R’의 우선순위 적용</li>
<li>테이블, 프로세스에 C, R, U, D가 모두 없는 경우</li>
<li>테이블에 C 또는 R이 없는 경우 (프로세스는 하나만 있어도 돌아감)<h3 id="인덱스index">인덱스(Index)</h3>
<h4 id="인덱스의-개념-및-선정기준-고려사항">인덱스의 개념 및 선정기준, 고려사항</h4>
</li>
<li>데이터 레코드를 빠르게 접근하기 위해 &lt;키 값, 포인터&gt;쌍으로 구성된 데이터 구조
▶ 인덱스 컬럼 선정</li>
<li>인덱스 컬럼의 분포도(Selectivity)가 10~15% 이내인 “컬럼”</li>
<li>가능한 한 수정이 빈번하지 않는 “컬럼”</li>
<li>ORDER BY, GROUP BY, UNION이 빈번한 “컬럼”</li>
<li>분포도가 좋은 컬럼은 단독 인덱스로 생성</li>
<li>인덱스들이 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성
▶ 설계 시 고려사항
 -새로 추가되는 인덱스는 기존 엑세스 경로에 영향을 미칠 수 있음</li>
<li>지나치게 많은 인덱스는 오버헤드 발생</li>
<li>넓은 범위 인덱스 처리 시 오히려 전체 처리보다 많은 오버헤드를 발생시킴</li>
<li>인덱스만의 추가적인 저장 공간이 필요</li>
<li>인덱스와 테이블 데이터의 저장 공간이 분리되도록 설계</li>
</ul>
<h4 id="인덱스-종류">인덱스 종류</h4>
<ul>
<li>클러스터드 인덱스(Clustered Index) / 넌클러스터드 인덱스(Non-Clustered Index)</li>
<li>트리 기반 인덱스 : 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것</li>
<li>비트맵 인덱스 : 인덱스 컬럼의 데이터를 Bit 값인 0, 1로 변환해 인덱스 키 사용</li>
<li>함수 기반 인덱스 : 컬럼에 특정 함수나 수식을 적용해 산출된 값을 사용하는 것</li>
<li>비트맵 조인 인덱스 : 다수의 조인된 객체로 구성된 인덱스</li>
<li>도메인 인덱스 : 개발자가 필요한 인덱스를 직접 만들어 사용하는 것 (확장형 인덱스)<h4 id="뷰view">뷰(View)</h4>
1) 뷰의 개요 및 특징</li>
<li>기본 테이블로부터 유도된, 이름을 가지는 가상 테이블로 기본 테이블과 같은 형태의 구조를 사용하며, 조작도 기본 테이블과 거의 같음</li>
<li>가상 테이블이기 때문에 물리적으로 구현되어 있지 않지만 사용자에게 있는 것처럼 간주됨 → 저장장치 내에 논리적으로 존재</li>
<li>정의된 뷰로 다른 뷰를 정의할 수 있음</li>
<li>뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제됨
속성    설명
REPLACE    뷰가 이미 존재하는 경우 재생성
FORCE    본 테이블의 존재 여부에 관계 없이 뷰 생성
NOFORCE    기본 테이블이 존재할 때만 뷰 생성
WITH CHECK OPTION    서브 쿼리 내의 조건을 만족하는 행만 변경
WITH READ ONLY    데이터 조작어(DML) 작업 불가</li>
</ul>
<p>2) 뷰의 장, 단점
▶ 장점
-논리적 데이터 독립성 제공
-접근 제어를 통한 자동 보안 제공
-사용자 데이터 관리 용이
▶ 단점
-독립적인 인덱스를 가질 수 없음
-뷰의 정의를 ALTER로 변경할 수 없음 → DROP하고 새로 CREATE해야 함
-뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따름</p>
<h3 id="클러스터cluster">클러스터(Cluster)</h3>
<p>1) 클러스터의 개요 및 특징</p>
<ul>
<li>데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법</li>
<li>인덱스의 단점을 해결한 기법 → 분포도(Selectivity)가 넓을수록 오히려 유리</li>
<li>분포도가 넓은 “테이블”의 클러스터링은 저장 공간의 절약이 가능</li>
<li>대량의 범위를 자주 액세스(조회)하는 경우 적용</li>
<li>인덱스를 사용한 처리 부담이 되는 넓은 분포도에 활용</li>
</ul>
<p>2) 클러스터의 선정기준 및 고려사항
▶ 클러스터 테이블 선정
-수정이 빈번하지 않는 “테이블”
-ORDER BY, GROUP BY, UNION이 빈번한 “테이블”
-처리 범위가 넓어 문제가 발생하는 경우 단일 테이블 클러스터링 사용
-조인이 많아 문제가 발생되는 경우는 다중 테이블 클러스터링 사용
▶ 설계 시 고려사항
-클러스터링 된 테이블은 조회 속도를 향상시켜주지만 입력, 수정, 삭제 시 성능이 저하됨(부하가 증가)
-대용량을 처리하는 트랜잭션은 전체 테이블을 스캔하는 일이 자주 발생하므로 클러스터링을 하지 않는 것이 좋음
-클러스터링 된 테이블에 클러스터드 인덱스를 생성하면 접근 성능이 향상됨</p>