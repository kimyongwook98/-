<h3 id="포인터">포인터</h3>
<p>1) 포인터와 포인터 변수</p>
<ul>
<li>포인터는 변수의 주소를 말하며, C언어에서는 주소를 제어할 수 있는 기능을 제공</li>
<li>C언어에서 변수의 주소를 저장할 때 사용하는 변수가 포인터 변수</li>
<li>포인터 변수는 필요에 의해 동적으로 할당되는 메모리 영역인 힙 영역에 접근하는 동적 변수
▶ 포인터 변수를 선언할 때는 자료의 형을 먼저 쓰고 변수명 앞에 간접 연산자 붙임
▶ 포인터 변수에 주소를 저장하기 위해 변수의 주소를 알아낼 때는 변수 앞에 번지 연산자 &amp; 붙임 → a = &amp;b
▶ 실행문에서 포인터 변수에 간접 연산자를 붙이면 해당 포인터 변수가 가리키는 곳의 값을 말함 → c = *a;</li>
</ul>
<p>2) 포인터와 배열</p>
<ul>
<li>배열을 포인터 변수에 저장한 후 포인터를 이용해 배열의 요소에 접근</li>
<li>배열 요소에 대한 주소를 지정할 때는 일반 변수와 동일하게 &amp; 연산자를 사용
ex) int a[5], *b;
b = a → 배열의 대표명을 적었으므로 a 배열의 시작 주소인 a[0]의 주소를 b에 저장함
b = &amp;a[0] → a 배열의 첫 번째 요소인 a[0]의 주소(&amp;)를 b에 저장함 </li>
</ul>
<h3 id="절차적-프로그래밍-언어">절차적 프로그래밍 언어</h3>
<p>1) 절차적 프로그래밍 언어의 개요</p>
<ul>
<li>일련의 처리 절차를 정해진 문법에 따라 순서대로 기술해나가는 언어</li>
<li>프로그램이 실행되는 절차(Procedure)를 중요시 함</li>
</ul>
<p>2) 절차적 프로그래밍 언어의 장단점</p>
<ul>
<li>컴퓨터의 처리 구조와 유사하여 실행 속도가 빠름</li>
<li>같은 코드를 복사하지 않고 다른 위치에서 호출 가능(이식성)</li>
<li>모듈 구성이 용이하며, 구조적인 프로그래밍이 가능함</li>
<li>프로그램을 분석하기 어렵고, 유지 보수나 코드의 수정이 어려움</li>
</ul>
<p>3) 절차적 프로그래밍 언어의 종류</p>
<ul>
<li>C    </li>
<li>1972년 미국 벨 연구소의 데니스 리치에 의해 개발됨</li>
<li>시스템 프로그래밍 언어로 널리 사용됨</li>
<li>자료의 주소를 조작할 수 있는 포인터 제공</li>
<li>고급 프로그래밍 언어, 저급 프로그래밍 언어의 특징을 모두 갖춤</li>
<li>UNIX의 일부가 C언어로 구현됨</li>
<li>컴파일러 방식의 언어</li>
<li>이식성이 좋아 컴퓨터 기종에 관계없이 프로그램 작성 가능</li>
<li>Algol(알골)    </li>
<li>수치계산이나 논리 연산을 위한 과학 기술 계산용 언어</li>
<li>PASCAL과 C언어의 모체</li>
<li>Cobol(코볼)    </li>
<li>사무 처리용 언어</li>
<li>영어 문장 형식으로 구성되어 있어 이해와 사용이 쉬움</li>
<li>4개의 DIVISION으로 구성됨</li>
<li>Fortran(포트란)    </li>
<li>과학 기술 계산용 언어</li>
<li>수학과 공학 분야의 공식이나 수식과 같은 형태로 프로그래밍 가능</li>
<li>Basic(베이직)</li>
<li>교육용으로 개발되어 언어의 문법이 쉬움</li>
<li>다양한 종류가 존재하며 서로 다른 종류 사이의 소스 코드는 호환되지 않음<h3 id="객체지향-프로그래밍-언어">객체지향 프로그래밍 언어</h3>
<h4 id="1-객체지향-프로그래밍-언어의-개요">1) 객체지향 프로그래밍 언어의 개요</h4>
</li>
<li>현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때도 객체들을 조립해서 프로그램을 작성할 수 있도록 한 프로그래밍 기법</li>
</ul>
<h4 id="2-객체지향-프로그래밍-언어의-장단점">2) 객체지향 프로그래밍 언어의 장단점</h4>
<ul>
<li>상속을 통한 재사용과 시스템의 확장이 용이하고, 코드의 재활용성이 높음</li>
<li>사용자와 개발자 사이의 이해를 쉽게 해주고, 대형 프로그램의 작성이 용이</li>
<li>프로그래밍 구현을 지원해 주는 정형화된 분석 및 설계 방법이 없음</li>
<li>구현 시 처리 시간이 지연됨 → 실행 속도가 느림</li>
</ul>
<h4 id="3-객체지향-프로그래밍-언어의-종류">3) 객체지향 프로그래밍 언어의 종류</h4>
<ul>
<li>C++    </li>
<li>C언어에 객체지향 개념을 적용한 언어</li>
<li>모든 문제를 객체로 모델링하여 표현함</li>
<li>C#    </li>
<li>Microsoft에서 개발한 객체지향 프로그래밍 언어</li>
<li>C++과 JAVA의 문법과 비슷함</li>
<li>JAVA와 달리 불안전 코드(Unsafe Code)와 같은 기술을 통해 플랫폼 간 상호 운용성 확보</li>
<li>JAVA(자바)</li>
<li>분산 네트워크 환경에 적용이 가능하며, 멀티스레드 기능을 제공하므로 여러 작업을 동시에 처리할 수 있음</li>
<li>운영체제 및 하드웨어에 독립적이며, 이식성이 강함</li>
<li>캡슐화가 가능하고 재사용성이 높음</li>
<li>Delphi(델파이)    </li>
<li>기본적인 문법은 파스칼 문법에 여러 기능들이 추가되어 존재</li>
<li>Windows 운영체제에서 모든 부분을 프로그래밍할 수 있는 언어</li>
<li>높은 생산성과 간결한 코드가 대표적인 장점</li>
<li>Smalltalk </li>
<li>1세대 객체지향 프로그래밍 언어</li>
<li>최초로 GUI를 제공한 언어</li>
</ul>
<h4 id="4-객체지향-프로그래밍-언어의-구성-요소">4) 객체지향 프로그래밍 언어의 구성 요소</h4>
<p>▶ 객체(Object)</p>
<ul>
<li>독립적으로 식별 가능한 이름을 갖고 있음</li>
<li>객체가 가질 수 있는 조건인 상태(State)는 일반적으로 시간에 따라 변함</li>
<li>객체와 객체는 상호 연관성에 의한 관계 형성</li>
<li>객체가 반응할 수 있는 메시지의 집합을 행위(연산, Method)라고 하며, 객체는 행위의 특징을 나타냄</li>
<li>객체는 일정한 기억장소를 갖고 있음</li>
</ul>
<p>▶ 클래스(Class)</p>
<ul>
<li>공통된 속성과 연산(행위)를 갖는 객체의 집합</li>
<li>객체지향 프로그램에서 데이터를 추상화하는 단위</li>
<li>각각의 객체들이 갖는 속성과 연산(Method)을 정의하고 있는 틀</li>
<li>슈퍼 클래스는 특정 클래스의 상위(부모) 클래스</li>
<li>서브 클래스는 특정 클래스의 하위(자식) 클래스</li>
</ul>
<p>▶ 인스턴스(Instance) </p>
<ul>
<li><p>클래스에 속한 각각의 객체</p>
</li>
<li><p>클래스로부터 새로운 객체를 생성하는 것을 인스턴스화(Instantiation)라고 함</p>
<p>▶ 메서드(Method)</p>
<ul>
<li>클래스로부터 생성된 객체를 사용하는 방법</li>
<li>전통적 시스템의 함수(Function) 또는 프로시저(Procedure)에 해당하는 연산</li>
</ul>
</li>
</ul>
<p>▶ 메시지(Message)
    - 객체에게 어떤 행위를 하도록 지시하기 위한 방법</p>
<h4 id="5-객체지향-프로그래밍-언어의-특징">5) 객체지향 프로그래밍 언어의 특징</h4>
<ul>
<li><strong>캡슐화(Encapsulation)</strong> </li>
<li>데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것</li>
<li>캡슐화된 객체의 세부 내용이 외부에 은폐(정보 은닉)되어, 변경이 발생할 때 오류의 파급효과가 적음</li>
<li>캡슐화된 객체들은 재사용이 용이함</li>
<li><strong>상속성(Inheritance)</strong></li>
<li>이미 정의된 상위 클래스(부모)의 모든 속성과 연산을 하위 클래스(자식)가 물려받는 것</li>
<li><strong>다형성(Polymorphism)</strong> </li>
<li>메시지에 의해 객체(클래스)가 연산을 수행하게 될 때, 하나의 메시지에 대해 각 객체(클래스)가 가지고 있는 고유의 방법(특성)으로 응답할 수 있는 능력</li>
<li><strong>추상화(Abstraction)</strong></li>
<li>불필요한 부분은 생략하고 객체의 속성 중 가장 중요한 것에만 중점을 두어 개략화, 모델화 하는 것</li>
<li>데이터의 공통된 성질을 추출하여 슈퍼 클래스를 선정하는 개념</li>
<li><strong>정보 은닉(Information Hiding)</strong>    </li>
<li>캡슐화에서 가장 중요한 개념으로, 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것</li>
</ul>