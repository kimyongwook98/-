<h3 id="경로-제어-트래픽-제어">경로 제어, 트래픽 제어</h3>
<h4 id="1-경로-제어-프로토콜routing-protocol">1) 경로 제어 프로토콜(Routing Protocol)</h4>
<ul>
<li><strong>RIP(Routing Information Protocol)</strong></li>
<li>IGP(Interior Gateway Protocol)로 벨만포드 알고리즘을 이용하여 최적의 경로를 설정하는 소규모 프로토콜</li>
<li>최대 홉 수 15홉 이하</li>
<li>거리 벡터 라우팅 프로토콜이라고도 함 </li>
<li>*<em>OSPF(Open Shortest Path First) *</em></li>
<li>IGP(Interior Gateway Protocol)로 RIP의 단점 개선을 위해 다익스트라 알고리즘 및 Link Static 기반으로 최단경로를 찾는 대규모 프로토콜</li>
<li><strong>BGP(Border Gateway Protocol)</strong>    </li>
<li>자치 시스템 간의 라우팅 프로토콜로, EGP(Exterior Gateway Protocol)의 단점을 보완하기 위해 만들어짐</li>
<li>초기에 BGP 라우터들이 연결될 때는 전체 경로를 나타내는 라우팅 테이블을 교환하고, 이후에는 변화된 정보만 교환</li>
</ul>
<h4 id="2-트래픽-제어traffic-control">2) 트래픽 제어(Traffic Control)</h4>
<ul>
<li>네트워크의 보호, 성능 유지, 네트워크 자원의 효율적인 이용을 위해 전송되는 패킷의 흐름 또는 그 양을 조절하는 기능으로 흐름 제어, 폭주(혼합) 제어, 교착상태 방지 기법이 있음</li>
</ul>
<h4 id="3-흐름-제어flow-control">3) 흐름 제어(Flow Control)</h4>
<ul>
<li>네트워크 내의 원활한 흐름을 위해 송, 수신 측 사이에 전송되는 패킷의 양이나 속도를 규제하는 기능</li>
<li>정지-대기(Stop-and-Wait) : 수신 측의 확인 신호(ACK)를 받은 후에 다음 패킷을 전송하는 방식 → 한번에 하나의 패킷 전송</li>
<li>슬라이딩 윈도우(Sliding Window) : 수시 측의 확인 신호(ACK)를 받지 않더라도 미리 정해진 패킷의 수만큼 연속적으로 전송하는 방식 → 한번에 여러 개 패킷 전송
(수신 측으로부터 송신한 패킷에 대한 긍정 수신 응답(ACK)이 전달된 경우 윈도우 크기는 증가하고, 수신 측으로부터 부정 수신 응답(NAK)이 전달된 경우 윈도우 크기는 감소)<h4 id="4-폭주혼잡-제어congestion-control">4) 폭주(혼잡) 제어(Congestion Control)</h4>
</li>
<li>흐름 제어(Flow Control)가 송, 수신 측 사이의 패킷 수를 제어하는 기능이라면, 혼잡 제어는 네트워크 내의 패킷 수를 조절하여 네트워크의 오버플로를 방지하는 기능</li>
</ul>
<p><strong>느린 시작(Slow Start)</strong><br />▶ 윈도우의 크기를 1, 2, 4, 8, … 같이 2배씩 지수적으로 증가시켜 초기에는 느리지만 갈수록 빨라짐</p>
<ul>
<li>전송 데이터의 크기가 임계 값에 도달하면 혼잡 회피 단계로 넘어감</li>
<li>혼잡 회피(Congestion Avoidance) : 느린 시작의 지수적 증가가 임계 값에 도달하면 혼잡으로 간주하고 회피를 위해 윈도우의 크기를 1씩 선형적으로 증가시켜 혼잡을 예방하는 방식</li>
</ul>
<h4 id="5-교착-상태dead-lock-방지">5) 교착 상태(Dead Lock) 방지</h4>
<ul>
<li>교환기 내에 패킷들을 축적하는 기억 공간이 꽉 차 있을 때 다음 패킷들이 기억 공간에 들어가기 위해 무한정 기다리는 형상</li>
</ul>
<h4 id="6-교착-상태-발생의-필요-충분-조건">6) 교착 상태 발생의 필요 충분 조건</h4>
<ul>
<li>상호 배제(Mutual Exclusion</li>
<li>점유와 대기(Hold and Wait)</li>
<li>환형 대기(Circular Wait)</li>
<li>비선점(Non-Preemption)</li>
</ul>
<h3 id="소프트웨어-개발-보안">소프트웨어 개발 보안</h3>
<h4 id="1-소프트웨어-개발-보안-관련-기관">1) 소프트웨어 개발 보안 관련 기관</h4>
<ul>
<li>감리법인    </li>
<li>감리 계획을 수립하고 협의</li>
<li>소프트웨어 보안 약점의 제거 여부 및 조치 결과 확인</li>
<li>사업자    </li>
<li>소프트웨어 개발 보안 관련 기술 수준 및 적용 계획 명시</li>
<li>소프트웨어 개발 보안 관력 인력을 대상으로 교육 실시</li>
<li>소프트웨어 개발 보안 가이드를 참조해 개발 → 개발기관</li>
<li>한국인터넷진흥원(KISA)    </li>
<li>소프트웨어 개발 보안 정책 및 가이드 개발</li>
<li>소프트웨어 개발 보안에 대한 기술을 지원하고, 교육과정 및 자격제도를 운영함 → 전문기관 </li>
<li>발주기관    </li>
<li>소프트웨어 개발 보안 계획 수립</li>
<li>소프트웨어 개발 보안 사업자 및 감리법인 선정</li>
<li>소프트웨어 개발 보안 준수 여부 점검</li>
<li>행정안전부    </li>
<li>소프트웨어 개발 보안 정책 총괄 → 정책기관</li>
<li>소프트웨어 개발 보안 관련 법규, 지침, 제도 정비</li>
</ul>
<h4 id="2-소프트웨어-개발-직무별-보안-활동">2) 소프트웨어 개발 직무별 보안 활동</h4>
<p>▶ 프로젝트 관리자(Project Manager) : 응용 프로그램에 대한 보안 전략 전달
▶ 요구사항 분석가(Requirement Specifier) : 요구사항 설명 및 정의
▶ 아키텍트(Architect) : 보안 기술 문제 이해
▶ 설계자(Designer) : 발생할 수 있는 보안 위험에 대해 이해 및 대응
▶ 구현 개발자(Implementer) : 시큐어 코딩 표준 준수 개발 및 문서화
▶ 테스트 분석가(Test Analyst) : 요구사항과 구현 결과 반복적 확인
▶ 보안 감시자(Security Auditor) : 전체 단계에서 활동 및 보안 보장</p>
<h3 id="secure-os">Secure OS</h3>
<h4 id="1-secure-os의-개요">1) Secure OS의 개요</h4>
<ul>
<li><p>기존의 운영체제(OS)에 내재된 보안 취약점을 해소하기 위해 보안 기능을 갖춘 커널을 이식하여 외부의 침입으로부터 시스템 자원을 보호하는 운영체제</p>
</li>
<li><p>암호적 분리(Cryptographic Separation) : 내부 정보를 암호화하는 방법</p>
</li>
<li><p>논리적 분리(Logical Separation) : 프로세스의 논리적 구역을 지정하여 구역을 벗어나는 행위를 제한하는 방법</p>
</li>
<li><p>시간적 분리(Temporal Separation) : 동일 시간에 하나의 프로세스만 수행되도록 하여 동시 실행으로 발생하는 보안 취약점을 제거하는 방법</p>
</li>
<li><p>물리적 분리(Physical Separation) : 사용자별로 특정 장비만 사용하도록 제한하는 방법</p>
</li>
</ul>
<h4 id="2-참조-모니터reference-monitor">2) 참조 모니터(Reference Monitor)</h4>
<ul>
<li>보호대상의 객체에 대한 접근통제를 수행하는 추상머신이며, 이를 실제로 구현한 것이 보안 커널
▶ 3가지 특징
-격리성(Isolation) : 부정 조작 불가능
-검증 가능성(Verifiability) : 적절히 구현됐다는 것 확인 가능
-완전성(Completeness) : 우회가 불가능</li>
</ul>
<h4 id="3-secure-os의-보안-기능">3) Secure OS의 보안 기능</h4>
<ul>
<li>식별 및 인증, 임의적 접근통제(DAC), 강제적 접근통제(MAC), 객체 재사용 보호, 완전한 조정, 신뢰 경로, 감사 및 감사기록 축소</li>
</ul>
<h3 id="회복-및-병행제어-데이터-표준화">회복 및 병행제어, 데이터 표준화</h3>
<p>1) 회복(Recovery)</p>
<ul>
<li>트랜잭션들을 수행하는 도중 장애가 발생하여 데이터베이스가 손상되었을 때 손상되기 이전의 정상 상태로 복구하는 작업
▶ 장애의 유형</li>
<li>트랜잭션 장애 : 트랜잭션 내부의 비정상적인 상황으로 인해 프로그램 실행이 중지되는 현상</li>
<li>시스템 장애 : 데이터베이스에 손상을 입히지는 않으나 하드웨어 오동작, 소프트웨어의 손상, 교착상태 등에 의해 모든 트랜잭션의 연속적인 수행에 장애를 주는 현상</li>
<li>미디어 장애 : 저장장치인 디스크 블록의 손상이나 디스크 헤드의 충돌 등에 의해 데이터베이스의 일부 또는 전부가 물리적으로 손상된 상태
▶ 회복 관리기(Recovery Management) : DMBS의 구성 요소, 트랜잭션 실행이 성공적으로 완료되지 못하면 트랜잭션이 데이터 베이스에 생성했던 모든 변화를 취소(Undo)시키고, 트랜잭션 수행 이전의 원래 상태로 복구하는 역할 담당
-메모리 덤프, 로그(Log)를 이용하여 회복 수행</li>
</ul>
<h4 id="2-병행제어concurrency-control">2) 병행제어(Concurrency Control)</h4>
<ul>
<li>다중 프로그램의 이점을 활용하여 동시에 여러 개의 트랜잭션을 병행수행할 때, 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호 작용을 제어하는 것
▶ 병행제어의 목적<br />-데이터베이스의 공유 최대화
-데이터베이스의 일관성 유지
-시스템 활용도 최대화
-사용자에 대한 응답 시간 최소화</li>
</ul>
<h4 id="3-병행수행의-문제점">3) 병행수행의 문제점</h4>
<ul>
<li>갱신 분실(Lost Update) : 두 개 이상의 트랜잭션이 같은 자료를 공유하여 갱신할 때 갱신 결과의 일부가 없어지는 현상 (덮어쓸 때)</li>
<li>비완료 의존성(Uncommitted Dependency) : 하나의 트랜잭션 수행이 실패한 후 회복되기 전에 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상, 임시 갱신이라고도 함
→ 현황파악 오류(Dirty Read)</li>
<li>모순성(Inconsistency) : 두 개의 트랜잭션이 병행수행될 때 원치 않는 자료를 이용함으로써 발생하는 문제, 불일치 분석이라고도 함 (일관성 결여)</li>
<li>연쇄 복귀(Cascading Rollback) : 병행수행되던 트랜잭션들 중 어느 하나에 문제가 생겨 Rollback하는 경우 다른 트랜잭션도 함께 Rollback되는 현상
(부분취소 불가능 현상)</li>
</ul>
<h4 id="4-데이터-표준화의-정의">4) 데이터 표준화의 정의</h4>
<ul>
<li>시스템을 구성하는 데이터 요소의 명칭, 정의, 형식, 규칙에 대한 원칙을 수립하고 적용하는 것을 의미
▶ 데이터 표준의 종류
-표준 단어 : 업무에서 사용하고 일정한 의미를 갖고 있는 최소 단위의 단어
-표준 도메인 : 문자, 숫자, 날짜, 시간형과 같이 컬럼을 성질에 따라 그룹화
-표준 코드 : 선택할 수 있는 값을 정형화하기 위해 기준에 맞게 이미 정의된 코드값
-표준 용어 : 단어, 도메인, 코드 표준이 정의되면 이를 바탕으로 표준 용어 구성</li>
</ul>
<h4 id="5-데이터-관리-조직">5) 데이터 관리 조직</h4>
<ul>
<li>데이터 표준 원칙이나 데이터 표준의 준수 여부 등을 관리하는 사람들</li>
<li>데이터 관리자(DA), 데이터베이스 관리자(DBA)</li>
</ul>