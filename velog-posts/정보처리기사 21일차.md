<h3 id="운영체제의-개념">운영체제의 개념</h3>
<h4 id="1-운영체제os-operating-system">1) 운영체제(OS; Operating System)</h4>
<ul>
<li>컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임</li>
<li>사용자 &gt; 응용 프로그램 &gt; 유틸리티 &gt; 운영체제 &gt; 하드웨어</li>
</ul>
<h4 id="2-운영체제의-목적">2) 운영체제의 목적</h4>
<ul>
<li>처리 능력(Throughput) : 일정 시간 내에 시스템이 처리하는 일의 양</li>
<li>반환 시간(Turn Around Time) : 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간</li>
<li>사용 가능도(Availability) : 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도</li>
<li>신뢰도(Reliability) : 시스템이 주어진 문제를 정확하게 해결하는 정도</li>
</ul>
<h4 id="3-운영체제의-기능">3) 운영체제의 기능</h4>
<ul>
<li>CPU, 메모리 공간, 프로세서(처리기, Processor), 기억장치(주기억장치, 보조 기억장치), 입출력 장치, 파일 및 정보 등의 자원 관리</li>
<li>다중 사용자와 다중 응용프로그램 환경 하에서 현재 상태를 파악하고 자원을 효율적으로 분배 및 관리하기 위해 스케줄링 기능 제공</li>
<li>사용자와 시스템 간의 편리한 인터페이스 제공, 입출력 장치와 사용자 프로그램 제어</li>
<li>데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공</li>
<li>시스템의 오류 검사 및 복구, 자원 보호 기능 제공</li>
<li>입출력에 대한 보조 기능 제공 → 가상 계산기 기능 제공<h4 id="4-운영체제의-주요-자원-관리">4) 운영체제의 주요 자원 관리</h4>
</li>
<li>프로세스 관리 : 프로세스 스케줄링 및 동기화 </li>
<li>기억장치 관리 : 프로세스에게 메모리 할당 및 회수</li>
<li>주변장치 관리 : 입출력장치 스케줄링 및 전반적 관리</li>
<li>파일 관리 : 파일 생성과 삭제, 변경, 유지 등</li>
</ul>
<h4 id="5-운영체제의-종류">5) 운영체제의 종류</h4>
<ul>
<li>Windows </li>
<li>Microsoft사가 개발 </li>
<li>GUI</li>
<li>UNIX </li>
<li>AT&amp;T 벨 연구소, MIT, Generic Electric 공동 개발 </li>
<li>CLI</li>
<li>LINUX</li>
<li>리누스 토발즈가 개발</li>
<li>UNIX와 호환 가능한 커널</li>
<li>누구나 활용 및 재배포 가능한 오픈 소스</li>
<li>CLI</li>
<li>MacOS</li>
<li>Apple 사가 UNIX를 기반으로 개발    </li>
<li>GUI</li>
<li>MS-DOS </li>
<li>Windows 이전에 사용되던 운영체제</li>
<li>CLI</li>
</ul>
<h4 id="6-windows의-주요-특징">6) Windows의 주요 특징</h4>
<p>▶ GUI(Graphic User Interface, 그래픽 사용자 인터페이스)</p>
<ul>
<li>키보드로 명령어를 직접 입력하지 않고, 마우스로 아이콘이나 메뉴를 선택하여 모든 작업을 수행하는 방식
→ 초보자도 쉽게 사용할 수 있게 GUI 채용</li>
</ul>
<p>▶ 선점형 멀티태스킹(Preemptive Mulit-Tasking)</p>
<ul>
<li>동시에 여러 개의 프로그램을 실행하면서 운영체제가 각 작업의 CPU 이용 시간을 제어하여 응용 프로그램 실행 중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식 
→ 하나의 응용 프로그램이 CPU를 독점하는 것을 방지할 수 있어 시스템 다운 현상없이 더욱 안정적인 작업을 할 수 있음</li>
</ul>
<p>▶ PnP(Plug and Play, 자동 감지 기능)</p>
<ul>
<li>컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 때, 해당 하드웨어를 사용하는 데 필요한 시스템 환경을 OS가 자동으로 구성
→ 운영체제가 하드웨어의 규격을 자동으로 인식하여 동작하게 해주므로 PC 주변장치를 연결할 때 사용자가 직접 환경을 설정하지 않아도 됨
→ PnP기능을 활용하기 위해서는 하드웨어와 소프트웨어 모두 PnP를 지원해야 함</li>
</ul>
<p>▶ OLE(Object Linking and Embedding)</p>
<ul>
<li>다른 여러 응용 프로그램에서 작성된 문자나 그림 등의 개체(Objects)를 현재 작성 중인 문서에 자유롭게 연결하거나 삽입(Embedding)하여 편집할 수 있음
→ OLE로 연결된 이미지를 원본 프로그램에서 수정하거나 편집하면 그 내용이 그대로 해당 문서에 반영됨</li>
</ul>
<p>▶ 255자의 긴 파일명</p>
<ul>
<li>VFAT(Virtual File Allocation Table)를 이용해 최대 255자까지 파일 이름 지정 가능 
→ 파일 이름으로는 \ / : * ? “ &lt; &gt; |를 제외한 모든 문자 및 공백을 사용할 수 있으며, 한글의 경우 127자까지 저장 가능</li>
</ul>
<p>▶ 개인 사용자(Single-User) 시스템</p>
<ul>
<li>컴퓨터 한 대를 한 사람만이 독점해서 사용</li>
</ul>
<h4 id="6-unix의-개요-및-특징">6) UNIX의 개요 및 특징</h4>
<ul>
<li>소스가 공개된 개방형 시스템(Open System)</li>
<li>시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제</li>
<li>다중 작업(Multi-Tasking, 멀티 태스킹) 지원<ul>
<li>다중 사용자(Multi-User) 지원</li>
<li>대부분 C언어로 작성되어 있어 이식성이 높으며 장치, 프로세스 간의 호환성이 높음</li>
<li>계층 구조(트리 구조)의 파일 시스템</li>
</ul>
</li>
</ul>
<p>→ 하드웨어 &gt; 커널(Kernel) &gt; 쉘(Shell) &gt; 유틸리티(Utility) &gt; 사용자(User)
▶ 커널
-UNIX의 가장 핵심적인 부분
-컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행
-하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할 담당
-프로세스 관리, 기억장치 관리, 파일 관리, 입출력 관리 등 수행</p>
<p>▶ 쉘(Shell)
-사용자의 명령어를 인식하여 프로그램을 호출하고, 명령을 수행하는 명령어 해석기
-주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조 기억장치에서 교체 처리가 가능
-시스템과 사용자 간의 인터페이스 역할을 담당
 -파이프라인 기능 지원 및 입, 출력 재지정을 통해 입출력의 방향 변경 가능
 -여러 종류의 쉘이 있음
 -DOS의 COMMAND.COM과 같은 기능 수행</p>
<h4 id="7-unix에서의-프로세스-간-통신">7) UNIX에서의 프로세스 간 통신</h4>
<ul>
<li>각 프로세스는 시스템 호출을 통해 커널의 기능을 사용하며, 프로세스 간 통신은 시그널(Signal), 파이프(Pipe), 소켓(Socket) 사용
▶ 시그널 : 간단한 메시지를 이용하여 통신, 초기 UNIX 시스템에서 사용
▶ 파이프 : 한 프로세스의 출력이 다른 프로세스의 입력으로 사용되는 단방향 통신 방식
▶ 소켓 : 프로세스 사이의 대화를 가능하게 하는 쌍방향 통신 방식</li>
</ul>
<h4 id="8-linux의-개요-및-특징">8) LINUX의 개요 및 특징</h4>
<ul>
<li>1991년 리누스 토발즈(Linus Torvalds)가 UNIX를 기반으로 개발한 운영체제</li>
<li>대부분의 특징이 UNIX와 동일하며 UNIX와 완벽하게 호환됨</li>
<li>프로그램 소스 코드가 무료로 공개되어 있음</li>
</ul>
<h4 id="9-macos의-개요-및-특징">9) MacOS의 개요 및 특징</h4>
<ul>
<li>1980년대 Apple사가 UNIX를 기반으로 개발한 운영체제</li>
<li>아이맥(iMAC)과 맥북 등 애플 사에서 생산하는 제품에서만 사용 가능</li>
<li>드라이버 설치 및 install과 uninstall의 과정이 단순</li>
</ul>
<h3 id="기억장치-관리">기억장치 관리</h3>
<h4 id="1-기억장치의-관리-전략의-개요">1) 기억장치의 관리 전략의 개요</h4>
<ul>
<li>보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기(When), 적재 위치(Where) 등을 지정하여 한정된 주기억장치의 공간을 효율적으로 사용하기 위함</li>
<li>반입(Fetch), 배치(Placement), 할당(Allocation), 교체(Replacemnet)</li>
</ul>
<h4 id="2-반입fetch-전략">2) 반입(Fetch) 전략</h4>
<ul>
<li>보조기억장치에 보관중인 프로그램이나 데이터를 언제(When) 주기억장치로 적재할 것인지를 결정하는 전략
▶ 요구 반입(Demand Fetch) : 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재
▶ 예상 반입(Anticipatory Fetch) : 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재</li>
</ul>
<h4 id="3-배치placement-전략">3) 배치(Placement) 전략</h4>
<ul>
<li>새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에(Where) 위치시킬 것인지를 결정하는 전략
▶ 최초 적합(First Fit) : 빈 영역 중에서 첫 번째 분할 영역에 배치
▶ 최적 적합(Best Fit) : 빈 영역 중에서 단편화를 가정 작게 남기는 분할 영역에 배치
▶ 최악 적합(Worst Fit) : 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치</li>
</ul>
<h4 id="4-교체replacement-전략">4) 교체(Replacement) 전략</h4>
<ul>
<li>이미 사용되고 있는 영역 중에서 어느(Who) 영역을 교체할지 결정하는 전략</li>
<li>FIFO, LRU, LFU, NUR, OPT, SCR</li>
</ul>
<h4 id="5-주기억장치-할당allocation의-개념">5) 주기억장치 할당(Allocation)의 개념</h4>
<ul>
<li>프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게(How) 할당할지 정함</li>
</ul>
<p>▶ 연속 할당 기법 : 프로그램을 주기억장치에 연속으로 할당하는 기법</p>
<ul>
<li>단일 분할 할당 기법 : 오버레이, 스와핑</li>
<li>다중 분할 할당 기법 : 고정(정적) 분할 할당 기법, 가변(동적) 분할 할당 기법</li>
</ul>
<p>▶ 분산 할당 기법 : 프로그램을 특정 단위의 조각으로 나누어 할당하는 기법</p>
<ul>
<li>페이징(Paging) 기법 / 세그먼테이션(Segmentation) 기법</li>
</ul>
<h4 id="6-가상기억장치-개요">6) 가상기억장치 개요</h4>
<ul>
<li>보조기억장치(하드디스크)의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법</li>
<li>주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용</li>
<li>주기억장치의 이용률과 다중 프로그래밍 효율을 높일 수 있음</li>
<li>가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의 주소를 주기억장치의 주소로 바꾸는 주소 변환 작업 필요</li>
<li>블록 단위로 나누어 사용하므로 연속 할당 방식의 단편화 해결 가능</li>
</ul>
<h4 id="7-페이징-기법">7) 페이징 기법</h4>
<ul>
<li>가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법</li>
<li>일정한 크기로 나눈 단위를 페이지(Page)라 하고, 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임(Page Frame)이라 함</li>
<li>외부 단편화는 발생하지 않으나, 내부 단편화 발생</li>
<li>주소 변환을 위해 페이지의 위치 정보를 갖고 있는 페이지 맵 테이블(Page Map Table) 필요 → 페이지 맵 테이블 사용으로 비용 증가, 처리 속도 감소</li>
</ul>
<h4 id="8-세그먼테이션segmentation-기법">8) 세그먼테이션(Segmentation) 기법</h4>
<ul>
<li>가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 기억공간을 절약하기 위해서 사용하는 실행시키는 방법</li>
<li>논리적인 크기로 나눈 단위를 세그먼트(Segment)라고 하며, 각 세그먼트는 고유한 이름과 크기를 가짐</li>
<li>기억장치의 사용자 관점을 보존하는 기억장치 관리 기법</li>
<li>주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 갖고 있는 세그먼트 맵 테이블(Segment Map Table) 필요</li>
<li>세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 없으며, 이를 위해 기억장치 보호키(Storage Protection Key)가 필요</li>
<li>내부 단편화는 발생하지 않으나, 외부 단편화 발생</li>
</ul>
<h4 id="8-페이지-교체-알고리즘">8) 페이지 교체 알고리즘</h4>
<p>▶ FIFO(First In First Out) = FCFS(First Come First Serve)
 -각 페이지가 주기억장치에 적재될 떄마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법</p>
<p>▶ LRU(Least Recently Used)
 -최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법
 -가장 오래 전에 사용된 페이지 교체</p>
<p>▶ LFU(Least Frequently Used)
 -사용 빈도가 가장 적은 페이지를 교체하는 기법</p>
<p>▶ OPT(OPTimal replacement, 최적 교체)
 -앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법
 -벨레이디(Belady)가 제안한 것으로, 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘</p>
<p>▶ NUR(Not Used Recently)
 -LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법
 -각 페이지마다 두 개의 비트, 즉 참조 비트와 변형 비트 사용
참조 비트    0    0    1    1
변형 비트    0    1    0    1
교체 순서    1    2    3    4</p>
<p>▶ SCR(Second Chance Replacement, 2차 기회 교체)
 -가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것으로, FIFO 기법의 단점 보완</p>
<h4 id="9-페이지-크기">9) 페이지 크기</h4>
<p>▶ 페이지 크기가 작을 경우
 -페이지 단편화가 감소되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어듬
 -불필요한 내용이 주기억장치에 적재될 확률이 적어서 효율적인 워킹 셋 유지 가능
 -Locality에 더 일치할 수 있기 때문에 기억장치 효율 높아짐
 -페이지 정보를 갖는 페이지 맵(사상) 테이블의 크기가 커지고, 매핑 속도가 늦어짐
 -디스크 접근 횟수가 많아져서 전체적인 입출력 시간은 늘어남</p>
<p>▶ 페이지 크기가 클 경우
 -페이지 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어남
 -불필요한 내용까지도 주기억장치에 적재될 수 있음
 -페이지 정보를 갖는 페이지 맵(사상) 테이블의 크기가 작아지고, 매핑 속도가 빨라짐
 -디스크 접근 횟수가 줄어들어 전체적인 입, 출력 효율성이 증가됨</p>
<h4 id="10-locality지역성-구역성">10) Locality(지역성, 구역성)</h4>
<ul>
<li><p>프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론</p>
</li>
<li><p>스래싱(Thrashing)을 방지하기 위한 워킹 셋 이론의 기반</p>
</li>
<li><p>데닝(Denning) 교수에 의해 구역성의 개념이 증명, 캐시 메모리 시스템의 이론적 근거</p>
</li>
<li><p><strong>시간적 구역성(Temporal Locality)</strong> </p>
</li>
<li><p>한 번 참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음</p>
</li>
<li><p>Loop, Stack, Subroutine, Counting, Totaling(집계) </p>
</li>
<li><p><strong>공간적 구역성(Spatial Locality)</strong> </p>
</li>
<li><p>한 페이지를 참조하면 그 근처의 페이지를 계속 참조할 가능성이 높음</p>
</li>
<li><p>Array(배열), Sequential Code(순차적 코드) </p>
</li>
</ul>
<h4 id="11-워킹-셋working-set">11) 워킹 셋(Working Set)</h4>
<ul>
<li>프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합</li>
<li>주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정됨</li>
<li>시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변화하기 때문에 워킹 셋은 시간에 따라 변경</li>
</ul>
<h4 id="12-페이지-부재-빈도pff-page-fault-frequency-방식">12) 페이지 부재 빈도(PFF; Page Fault Frequency) 방식</h4>
<ul>
<li>페이지 부재율에 따라 주기억장치에 있는 페이지 프레임의 수를 늘리거나 줄여 페이지 부재율을 적정 수준으로 유지하는 방식</li>
<li>페이지 부재(Page Fault)는 프로세스 실행 시 참조할 페이지가 주기억장치에 없는 현상이며, 페이지 부재 빈도는 페이지 부재가 일어나는 횟수를 의미</li>
</ul>
<h4 id="13-프리페이징prepaging">13) 프리페이징(Prepaging)</h4>
<ul>
<li>처음의 과도한 페이지 부재를 방지하기 위해 필요할 것 같은 모든 페이지를 미리 한꺼번에 페이지 프레임에 적재하는 기법
→ 기억장치에 들어온 페이지들 중에서 사용되지 않는 페이지가 많을 수도 </li>
</ul>
<h4 id="14-스래싱thrashing">14) 스래싱(Thrashing)</h4>
<ul>
<li>프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상
→ 전체 시스템 성능 저하</li>
<li>다중 프로그래밍(멀티 태스킹)의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만, 다중 프로그래밍의 정도가 더욱 커지면 스래싱이 나타나고, CPU의 이용률은 급격히 감소</li>
</ul>
<p>▶ 스래싱 현상 방지 방법
 -다중 프로그래밍의 정도를 적정 수준으로 유지
 -페이지 부재 빈도(Page Fault Frequency)를 조절해 사용
 -워킹 셋(Working Set)을 유지함
 -부족한 자원을 증설하고, 일부 프로세스를 중단시킴</p>
<h3 id="프로세스-및-스케줄링">프로세스 및 스케줄링</h3>
<h4 id="1-프로세스process의-정의">1) 프로세스(Process)의 정의</h4>
<ul>
<li>일반적으로 프로세서(처리기, Processor), 즉 CPU에 의해 처리되는 사용자 프로그램, 시스템 프로그램인 실행중인 프로그램을 의미하며 작업(Job), 태스크(Task)라고도 함</li>
<li>프로세서(Processor) → 프로세스(Process) → 프로시저(Procedure, 절차)</li>
</ul>
<p>▶ 프로세스의 정의
 -프로시저가 활동중인 것
 -비동기적 행위를 일으키는 주체
 -운영체제가 관리하는 실행 단위
 -실행중인 프로그램
 -PCB(Process Control Block)을 가진 프로그램
 -실기억장치에 저장된 프로그램
 -프로세서가 할당되는 실체로서, 디스패치가 가능한 단위</p>
<h4 id="2-pcbprocess-control-block-프로세스-제어-블록">2) PCB(Process Control Block, 프로세스 제어 블록)</h4>
<ul>
<li>프로세스 고유 식별자    : 프로세스를 구분할 수 있는 고유의 번호</li>
<li>프로세스의 현재 상태 : 준비, 대기, 실행 등의 프로세스 상태</li>
<li>프로그램 카운터 : 실행될 명령어의 주소를 가지고 있는 레지스터</li>
<li>CPU 레지스터 정보 : 누산기, 인덱스 레지스터, 범용 레지스터 등에 대한 정보</li>
<li>스케줄링 및 프로세스의 우선순위 : 스케줄링 정보 및 프로세스가 실행될 우선 순위</li>
<li>계정 정보 : CPU 사용 시간, 실제 사용 시간, 한정된 시간</li>
<li>입출력 상태 정보 : 입출력장치, 개방된 파일 목록</li>
<li>메모리장치 관리 정보 : 기준 레지스터, 페이지 테이블에 대한 정보</li>
<li>포인터 : 프로세스가 위치한 메모리 및 할당된 자원에 대한 포인터</li>
</ul>
<h4 id="3-프로세스-상태-전이">3) 프로세스 상태 전이</h4>
<p><img alt="" src="https://velog.velcdn.com/images/kimyongwook98/post/e16bcebe-e5c6-43bf-9073-db167e67ccd0/image.png" /></p>
<h4 id="4-프로세스-상태-전이-관련-용어">4) 프로세스 상태 전이 관련 용어</h4>
<p>Dispatch : 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정
Wake Up    : 프로세스가 대기 상태에서 준비 상태로 전이되는 과정
Spooling : 나중에 한꺼번에 입, 출력하기 위해 디스크에 저장하는 과정</p>
<h4 id="5-스레드">5) 스레드</h4>
<ul>
<li><p>프로세스 내의 작업 단위로, 시스템의 여러 자원을 할당받아 실행하는 단위
▶ 단일 스레드 : 하나의 프로세스에 하나의 스레드가 존재하는 경우
▶ 다중 스레드 : 하나의 프로세스에 하나 이상의 스레드가 존재하는 경우 </p>
</li>
<li><p>프로세스의 일부 특성을 갖고 있기 떄문에 경량 프로세스라고도 함</p>
</li>
<li><p>동일 프로세스 환경에서 서로 독립적인 다중 수행 가능
→ 하나의 프로세스를 여러 개의 스레드로 생성해 병행성 증진 및 성능과 처리율 향상
 프로그램 응답 시간 단축과 기억장소의 낭비가 줄어들고 통신이 향상됨 </p>
<h4 id="6-스케줄링scheduling의-개요">6) 스케줄링(Scheduling)의 개요</h4>
</li>
<li><p>프로세스가 생성되어 실행될 떄 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업</p>
</li>
<li><p><strong>장기 스케줄링(작업 스케줄링, 상위 스케줄링)</strong> : 어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할 것인가를 결정하여 준비상태 큐로 보내는 작업
→ 작업 스케줄러에 의해 수행됨</p>
</li>
<li><p><strong>중기 스케줄링</strong> : 어떤 프로세스들이 CPU를 할당받을 것인지 결정하는 작업</p>
</li>
<li><p><strong>단기 스케줄링(프로세서 스케줄링, 하위 스케줄링)</strong> : 프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업
→ 프로세서 스케줄링 및 문맥 교환은 프로세서 스케줄러에 의해 수행됨</p>
</li>
<li><p><strong>문맥 교환(Context Switching)</strong> : 하나의 프로세스에서 다른 프로세스로 CPU가 할당되는 과정에서 발생되는 것</p>
</li>
</ul>
<h4 id="7-스케줄링의-목적">7) 스케줄링의 목적</h4>
<ul>
<li>공정성 : 모든 프로세스에 공정하게 할당</li>
<li>처리량 증가 : 단위 시간당 프로세스 처리량 증가</li>
<li>CPU 이용률 증가 : CPU 낭비 시간 줄이고, 사용되는 시간 비율 증가</li>
<li>우선순위 제도 : 우선순위가 높은 프로세스 먼저 실행</li>
<li>오버헤드 최소화 : 오버헤드 최소화</li>
<li>응답시간(Response Time, 반응 시간) 최소화 : 작업 지시 및 반응 시작 시간 최소화</li>
<li>반환 시간(Turn Around Time) 최소화 : 제출한 시간부터 실행 완료 시간 최소화</li>
<li>대기 시간 최소화 : 준비상태 큐에서 대기하는 시간 최소화</li>
<li>균형 있는 자원의 사용: 메모리, 입, 출력장치 등의 자원을 균형 있게 사용</li>
<li>무한 연기 회피 : 자원을 사용하기 위해 무한정 연기되는 상태 회피
→ CPU이용률, 처리율, 반환 시간, 대기 시간, 응답 시간</li>
</ul>
<h4 id="8-프로세스-스케줄링의-기법">8) 프로세스 스케줄링의 기법</h4>
<p>▶ 선점(Preemptive) 스케줄링 : 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 선점할 수 있는 기법</p>
<ul>
<li>우선순위가 높은 프로세스 빠르게 처리 가능</li>
<li>빠른 응답 시간을 요구하는 대화식 시분할 시스템(Time Sharing System)에 사용<ul>
<li>많은 오버헤드 발생</li>
<li>선점이 가능하도록 일정 시간 배당에 대한 인터럽트용 타이머 클록 필요</li>
<li>Round Robin, SRT(Shortest Remaining Time), MLQ(Multi-Level Queue), MFQ</li>
</ul>
</li>
</ul>
<p>▶ 비선점(Non-Preemptive) 스케줄링 : 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 선점할 수 없는 기법</p>
<ul>
<li>CPU를 할당 받으면 해당 프로세스가 완료될 때까지 CPU 사용</li>
<li>모든 프로세스에 대한 요구를 공정하게 처리 가능</li>
<li>프로세스 응답 시간의 예측 용이</li>
<li>일괄 처리 방식에 적합</li>
<li>중요한 작업(짧은 작업)이 중요하지 않은 작업(긴 작업)을 기다리는 경우 발생
→ 가뭄 현상<ul>
<li>우선순위(Priority), 기한부(Deadline), FCFS(FIFO), SJF(Shortest Job First), HRN</li>
</ul>
</li>
</ul>
<h4 id="hrnhighest-response-ratio-next">HRN(Highest Response-ratio Next)</h4>
<ul>
<li>SJF 기법의 가뭄 현상을 보완하기 위한 방식으로, 대기 시간이 긴 프로세스일 경우 우선순위가 높아지고, 우선순위 계산식의 수치가 가장 높은 것부터 낮은 순으로 우선순위를 부여해 긴 작업과 짧은 작업 간의 지나친 불평등을 해소함
→ HRN 우선순위 계산식 : (대기시간 + 서비스시간) / 서비스시간</li>
</ul>