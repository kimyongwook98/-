<h3 id="보안-및-api">보안 및 API</h3>
<p>1) 소프트웨어 개발 보안의 개요</p>
<ul>
<li><p>소프트웨어 개발 과정에서 발생할 수 있는 보안 취약점을 최소화하여 보안 위협으로부터 안전한 소프트웨어를 개발하기 위한 일련의 보안 활동을 의미</p>
</li>
<li><p>시큐어 코딩(Secure Coding)</p>
</li>
<li><p>기밀성(Confidentiality), 무결성(Integrity), 가용성(Availability) 유지하는 것을 목표</p>
</li>
<li><p>정부에서 제공하는 소프트웨어 개발 보안 가이드를 참고하여 소프트웨어 개발 과정에서 점검해야 할 보안 항목들을 점검</p>
</li>
</ul>
<p>2) 소프트웨어 개발 보안 점검 항목</p>
<ul>
<li><strong>세션 통제</strong> : 세션의 연결과 연결로 인해 발생하는 정보를 관리하는 것
※ 세션 : 서버와 클라이언트의 연결
※ 보안 약점 : 불충분한 세션 관리, 잘못된 세션에 의한 정보 노출 등</li>
<li><strong>입력 데이터 검증 및 표현</strong> : 입력 데이터에 대한 유효성 검증체계를 갖추고, 검증 실패 시 이를 처리할 수 있도록 코딩하는 것
※ 보안 약점: SQL 삽입, 경로 조작 및 자원 삽입, 크로스사이트 스크립팅(XSS)</li>
<li><strong>보안 기능</strong> : 인증, 접근제어, 기밀성, 암호화 등의 기능
※ 보안 약점 : 적절한 인증 없는 중요기능 허용, 부적절한 인가,
사이트 간 요청 위조(CSRF, Cross-Site Request Forgery) 등</li>
<li><strong>시간 및 상태</strong> : 동시 수행을 지원하는 병렬 처리 시스템이나 다수의 프로세스가 동작하는 환경에서 시간과 실행 상태를 관리하여 시스템이 원활히 동작되도록 코딩하는 것
※ 보안 약점: 종료되지 않는 반복문 또는 재귀함수, 검사 시점과 사용 시점(TOCTOU; Time of Check Time of Use) 경쟁조건 등</li>
<li><strong>에러처리</strong> : 소프트웨어 실행 중 발생할 수 있는 오류들을 사전에 정의하여 에러로 인해 발생할 수 있는 문제들을 예방하는 것
※ 보안 약점: 오류 메시지를 통한 정보 노출, 오류 상황 대응 부재 등</li>
<li><em>코드 오류*</em> : 개발자들이 코딩 중 실수하기 쉬운 타입 변환, 자원의 반환 등을 고려하며 코딩하는 것
※ 보안 약점: 부적절한 자원 해제, 널 포인터(Null Pointer) 역참조 등</li>
<li><em>캡슐화*</em> : 데이터(속성)와 데이터를 처리하는 함수를 하나의 객체로 묶어 코딩하는 것
※ 보안 약점: 제거되지 않고 남은 디버그 코드, 잘못된 세션에 의한 데이터 정보 노출 등</li>
<li><em>API 오용*</em> : API를 잘못 사용하거나 보안에 취약한 API를 사용하지 않도록 고려하여 코딩하는 것
※ 보안 약점: 취약한 API 사용, DNS lookup에 의존한 보안결정 등</li>
</ul>
<p>3) API(Application Programming Interface)</p>
<ul>
<li>응용 프로그램 개발 시 운영체제나 프로그래밍 언어 등에 있는 라이브러리를 이용할 수 있도록 함으로써 효율적인 소프트웨어 구현을 도와주는 인터페이스</li>
<li>개발에 필요한 여러 도구를 제공</li>
<li>누구나 무료로 사용할 수 있게 공개된 API를 Open API라고 함</li>
<li>Windows API, 단일 유닉스 규격(SUS), Java API, 웹 API 등</li>
</ul>
<h3 id="배치-프로그램">배치 프로그램</h3>
<p>1) 배치 프로그램(Batch Program)의 개요 
-사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하는 것</p>
<ul>
<li>이벤트성 배치 : 특정 조건(이벤트)을 설정해두고 조건이 충족될 때만 수행</li>
<li>On-Demand 배치 : 사용자 요청 시 수행</li>
<li>정기 배치 : 일, 주, 월과 같이 정해진 기간에 정기 수행</li>
</ul>
<ul>
<li>대용량 데이터 : 대량의 데이터를 가져오거나, 전달하거나, 계산 등의 처리가 가능해야 함</li>
<li>자동화 : 심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행돼야 함</li>
<li>견고성    : 잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 일 없이 수행돼야 함</li>
<li>안정성/신뢰성 : 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 함</li>
<li>성능 : 다른 응용 프로그램(애플리케이션)의 수행을 방해하지 않아야 하고, 지정된 시간 내에 처리가 완료돼야 함</li>
</ul>
<p>2) 배치 스케줄러(Batch Scheduler), 잡 스케줄러(Job Scheduler)</p>
<ul>
<li>일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구
▶ 스프링 배치(Spring Batch) : Spring 프레임워크의 특성을 그대로 가져와 스프링이 가지고 있는 다양한 기능들을 모두 사용할 수 있는 오픈 소스 프레임워크<ul>
<li>주요 구성 요소 : Job, Job Launcher, Job Repository, Step
▶ 쿼츠(Quartz) : Spring 프레임워크로 개발되는 응용 프로그램들의 일괄 처리를 위한 다양한 기능을 제공하는 오픈 소스 라이브러리</li>
<li>주요 구성 요소 : Job, Job Detail, Trigger, Scheduler</li>
</ul>
</li>
</ul>
<h3 id="패키지-소프트웨어">패키지 소프트웨어</h3>
<p>1) 패키지 소프트웨어(Package Software)의 개요</p>
<ul>
<li>기업에서 일반적으로 사용하는 여러 기능들을 통합하여 제공하는 소프트웨어</li>
<li>기업에서 패키지 소프트웨어를 구입해 기업 환경에 적합하게 커스터마이징 후 사용</li>
<li>기능 요구사항을 70% 이상 충족시키는 패키지 소프트웨어 사용</li>
</ul>
<p>2) 패키지 소프트웨어 vs 전용 개발 소프트웨어</p>
<p>기능 요구사항    : 70% 이상 충족시키는 패키지 소프트웨어 // 모든 기능 요구사항 반영 가능
안정성    : 품질이 검증됐고, 업계 표준 준용 // 개발자의 역량에 따라 달라짐
라이선스 : 판매자 // 회사
생산성 : 개발을 위한 인력과 시간 절약 가능 // 개발을 위한 인력과 시간 필요
호환성 : 보장 안됨 // 설계 단계부터 고려하며 개발해서 호환성 좋음
유지보수 : 결함 발생 시 즉시 대응 어려움 // 결함 발생 시 즉시 대응 가능</p>
<h3 id="데이터-타입">데이터 타입</h3>
<ul>
<li><p>변수(Variable)에 저장될 데이터의 형식을 나타내는 것으로, 변수에 값을 저장하기 전에 문자형, 정수형, 실수형 등 어떤 형식의 값으로 저장할지 선언하는 것</p>
</li>
<li><p>불린 타입(Boolean Type, bool) : 조건의 참(True), 거짓(False)여부를 판단하여 저장할 때 사용(기본값 false) </p>
</li>
<li><p>문자 타입(Character Type, char) : 한 문자를 저장할 때 사용
→ 작은따옴표(‘)안에 표시    ‘A’, ‘a’, ‘1’, ‘*’</p>
</li>
<li><p>문자열 타입(Character String Type, string) : 문자열을 저장할 때 사용
→ 큰따옴표(“)안에 표시    “Hello!”, “1+2=3”</p>
</li>
<li><p>정수 타입(Integer Type, int) : 정수, 소수점이 없는 숫자를 저장할 때 사용 (1, -1, 10, -100)</p>
</li>
<li><p>부동 소수점 타입(Floating Point Type, float) : 실수, 소수점 이하가 있는 숫자를 저장할 때 사용 (0.123, -1.6)</p>
</li>
<li><p>배열 타입(Array Type, array) : 같은 타입의 데이터 집합을 만들어 저장할 때 사용
→ 데이터는 중괄호{ } 안에 콤마(,)로 구분하여 값들을 나열함    {1, 2, 3, 4, 5}</p>
</li>
</ul>
<p>▶ C/C++의 데이터 타입 크기</p>
<ul>
<li>문자/부호없는 문자형    </li>
<li>char/unsigned char - 1Byte</li>
<li>정수/부호없는 정수형    </li>
<li>short/unsigned short - 2Byte</li>
<li>int/unsigned int - 4Byte</li>
<li>long/unsigned long - 4Byte</li>
<li>long long - 8Byte</li>
<li>실수</li>
<li>float - 4Byte</li>
<li>double - 8Byte</li>
<li>long double - 8Byte</li>
</ul>
<h3 id="변수">변수</h3>
<p>1) 변수(Variable)의 개요</p>
<ul>
<li>컴퓨터가 명령을 처리하는 도중 발생하는 값을 저장하기 위한 공간으로, 변할 수 있는 값</li>
</ul>
<p>2) 변수명 작성 규칙</p>
<ul>
<li>영문자, 숫자, _(under bar) 사용 가능 →  a, A, a1, _, _korea O / text-color X</li>
<li>첫 글자는 영문자(대, 소문자), _(under bar)로 시작할 수 O / 숫자는 X</li>
<li>글자 수에 제한 없고, 대, 소문자 구분</li>
<li>공백이나 *, +, -, / 등의 특수문자를 사용할 수 없음 → my student, &lt;a, $a, X</li>
<li>예약어를 변수명으로 사용할 수 없음 → if, for, while X</li>
<li>변수 선언 시 문장 끝에 반드시 세미콜론(;)을 붙여야 함</li>
</ul>
<p>3) 예약어 – C언어</p>
<ul>
<li>제어문    </li>
<li>반복    : do, for, while</li>
<li>선택    : case, default, else, if, switch</li>
<li>분기    : break, continue, goto, return</li>
<li>자료형 : char, short, int, long, float, double, enum, signed, unsigned, union, void, struct, typedef</li>
<li>기억 클래스 : auto, register, static, extern</li>
<li>기타 : const, sizeof, volatile</li>
</ul>
<p>4) 기억 클래스</p>
<ul>
<li>변수 선언 시 메모리 내에 변수의 값을 저장하기 위한 기억영역이 할당되는데, 할당 되는 기억영역에 따라 사용 범위에 제한이 있다. 이러한 기억영역을 결정하는 작업을 기억 클래스(Storage Class)</li>
</ul>
<p>자동 변수 : 메모리(스택)    / auto / 일시적 / 지역적
레지스터 변수 : 레지스터 / register / 일시적 / 지역적<br />정적 변수(내부) : 메모리(데이터) / static / 영구적 / 지역적<br />정적 변수(외부) : 메모리(데이터) / static / 영구적 / 전역적
외부 변수 : 메모리(데이터) / extern / 영구적 / 전역적        </p>
<p>5) 변수의 선언</p>
<ul>
<li>자료형 변수명 = 값;
▶ 자료형: 변수에 저장될 자료의 형식 지정
▶ 변수명: 사용자가 원하는 이름을 임의로 지정 (변수명 작성 규칙 준수)
▶ 값: 변수를 선언하면서 초기화할 값을 지정</li>
</ul>
<h3 id="연산자">연산자</h3>
<p>1) 산술 연산자
** : 제곱
// : 나누기 연산 후 소수점 이하의 수를 버리고, 정수 부분의 몫을 구함
% : 나누기 연산 후 몫이 아닌 나머지를 구함
++ : 증감 연산자 (전치; 먼저 변수의 값을 증감시킨 후 연산에 사용)
-- : 감소 연산자 (후치; 먼저 변수를 연산에 사용한 후 값을 증감시킴)</p>
<p>2) 시프트 연산자</p>
<ul>
<li>(&lt;&lt;) : 왼쪽 시프트    / 비트를 왼쪽으로 이동
ex) 00101 → 01010</li>
<li>(&gt;&gt;) : 오른쪽 시프트 / 비트를 오른쪽으로 이동
ex) 00101 → 00010</li>
</ul>
<p>3) 관계 연산자
== : 같다
!= : 같지 않다</p>
<p>4) 비트 연산자</p>
<ul>
<li>비트별(0, 1)로 연산해 결과를 얻는 연산자
&amp; : and (모든 비트가 1일 때만 1)
| : or    (모든 비트 중 한 비트라도 1이면 1)
^ : xor    (모든 비트가 같으면 0, 하나라도 다르면 1)
~ : not    (각 비트의 부정, 0이면 1, 1이면 0)</li>
</ul>
<p>5) 논리 연산자</p>
<ul>
<li>두 개의 논리 값을 연산하여 참(true, 1) 또는 거짓(false, 0)을 결과로 얻는 연산자
&amp;&amp; : and (모두 참(1)이면 참(1))
|| : or    (하나라도 참(1)이면 참(1))
! : not    (부정)</li>
</ul>
<p>6) 조건 연산자(삼항 연산자)</p>
<ul>
<li>조건에 따라 서로 다른 수식 수행 / if(?), else(:)</li>
<li>조건 수식 ? 수식1 : 수식2;
→ ‘조건 수식’이 참(true, 1)이면 ‘수식1’ 수행, 거짓(false, 0)이면 ‘수식2’ 수행</li>
</ul>
<p>7) 대입 연산자</p>
<ul>
<li>+= / a = a+1</li>
<li>-= / a = a-1</li>
<li><em>= / a = a</em>1</li>
<li>/= / a = a/1</li>
<li>%= / a = a%1</li>
<li>&lt;&lt;= / a = a&lt;&lt;1</li>
<li>(&gt;&gt;=) / a = a&gt;&gt;1</li>
</ul>
<p>8) 기타 연산자
sizeof : 자료형의 크기 표시
,(콤마 comma) : 왼쪽에서 오른쪽으로 순서대로 수행되며, 순서를 콤마로 구분
(자료형) : 사용자가 자료형을 다른 자료형으로 변환할 때 사용하는 것
ex) a = (int)1.3 + (int)1.4; → a = 2</p>
<p>9) 연산자 우선순위
<img alt="" src="https://velog.velcdn.com/images/kimyongwook98/post/dccfc778-6395-40a8-9e6f-8a3956834aa3/image.PNG" /></p>